/**
 * AdminAlert Model
 * Handles administrator-visible safety notifications
 *
 * ACCESS CONTROL:
 * - Alerts have authorization levels: admin, safety_reviewer, counselor, superadmin
 * - Detail access is logged for audit
 * - Raw conversation text is NOT stored in alerts
 */

const database = require('../database');
const { v4: uuidv4 } = require('uuid');

/**
 * Convert database row to admin alert object
 */
function rowToAdminAlert(row) {
  if (!row) return null;
  return {
    id: row.id,
    safetyFlagId: row.safety_flag_id,
    userId: row.user_id,
    personaId: row.persona_id,
    conversationId: row.conversation_id,
    alertType: row.alert_type,
    category: row.category,
    severity: row.severity,
    confidence: row.confidence,
    title: row.title,
    redactedSummary: row.redacted_summary,
    recommendedAction: row.recommended_action,
    status: row.status,
    viewedAt: row.viewed_at,
    viewedBy: row.viewed_by,
    acknowledgedAt: row.acknowledged_at,
    acknowledgedBy: row.acknowledged_by,
    resolvedAt: row.resolved_at,
    resolvedBy: row.resolved_by,
    resolutionNotes: row.resolution_notes,
    requiresAuthorization: row.requires_authorization,
    authorizationLevel: row.authorization_level,
    detailAccessedAt: row.detail_accessed_at,
    detailAccessedBy: row.detail_accessed_by,
    autoGenerated: row.auto_generated,
    expiresAt: row.expires_at,
    createdAt: row.created_at,
    updatedAt: row.updated_at,
    // Joined fields
    userDisplayName: row.user_display_name,
    personaName: row.persona_name
  };
}

/**
 * Create a new admin alert
 */
async function create(alertData) {
  const id = uuidv4();

  const result = await database.query(`
    INSERT INTO admin_alerts (
      id, safety_flag_id, user_id, persona_id, conversation_id,
      alert_type, category, severity, confidence,
      title, redacted_summary, recommended_action,
      requires_authorization, authorization_level,
      status, auto_generated, expires_at
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, 'new', $15, $16)
    RETURNING *
  `, [
    id,
    alertData.safetyFlagId || null,
    alertData.userId,
    alertData.personaId || null,
    alertData.conversationId,
    alertData.alertType || 'safety_threshold',
    alertData.category,
    alertData.severity || 'moderate',
    alertData.confidence,
    alertData.title,
    alertData.redactedSummary,
    alertData.recommendedAction || null,
    alertData.requiresAuthorization !== false,
    alertData.authorizationLevel || 'safety_reviewer',
    alertData.autoGenerated !== false,
    alertData.expiresAt || null
  ]);

  return rowToAdminAlert(result.rows[0]);
}

/**
 * Find alert by ID
 */
async function findById(alertId) {
  const result = await database.query(`
    SELECT a.*, u.display_name as user_display_name, p.name as persona_name
    FROM admin_alerts a
    LEFT JOIN users u ON a.user_id = u.id
    LEFT JOIN personas p ON a.persona_id = p.id
    WHERE a.id = $1
  `, [alertId]);

  return rowToAdminAlert(result.rows[0]);
}

/**
 * Find active alerts with filters
 */
async function findActive(options = {}) {
  const {
    status = null,
    severity = null,
    category = null,
    limit = 50,
    offset = 0,
    includeExpired = false
  } = options;

  let query = `
    SELECT a.*, u.display_name as user_display_name, p.name as persona_name
    FROM admin_alerts a
    LEFT JOIN users u ON a.user_id = u.id
    LEFT JOIN personas p ON a.persona_id = p.id
    WHERE 1=1
  `;
  const params = [];
  let paramIndex = 1;

  if (!includeExpired) {
    query += ` AND (a.expires_at IS NULL OR a.expires_at > NOW())`;
  }

  if (status) {
    if (Array.isArray(status)) {
      query += ` AND a.status = ANY($${paramIndex++})`;
      params.push(status);
    } else {
      query += ` AND a.status = $${paramIndex++}`;
      params.push(status);
    }
  } else {
    // Default: exclude resolved and dismissed
    query += ` AND a.status NOT IN ('resolved', 'dismissed')`;
  }

  if (severity) {
    if (Array.isArray(severity)) {
      query += ` AND a.severity = ANY($${paramIndex++})`;
      params.push(severity);
    } else {
      query += ` AND a.severity = $${paramIndex++}`;
      params.push(severity);
    }
  }

  if (category) {
    query += ` AND a.category = $${paramIndex++}`;
    params.push(category);
  }

  // Order by severity priority, then by date
  query += `
    ORDER BY
      CASE a.severity
        WHEN 'critical' THEN 1
        WHEN 'high' THEN 2
        WHEN 'elevated' THEN 3
        WHEN 'moderate' THEN 4
        ELSE 5
      END,
      a.created_at DESC
    LIMIT $${paramIndex++} OFFSET $${paramIndex}
  `;
  params.push(limit, offset);

  const result = await database.query(query, params);
  return result.rows.map(rowToAdminAlert);
}

/**
 * Count active alerts by status and severity
 */
async function countActive() {
  const result = await database.query(`
    SELECT
      status,
      severity,
      COUNT(*) as count
    FROM admin_alerts
    WHERE (expires_at IS NULL OR expires_at > NOW())
      AND status NOT IN ('resolved', 'dismissed')
    GROUP BY status, severity
  `);

  return result.rows;
}

/**
 * Get alerts requiring immediate attention
 */
async function getUrgent() {
  const result = await database.query(`
    SELECT a.*, u.display_name as user_display_name, p.name as persona_name
    FROM admin_alerts a
    LEFT JOIN users u ON a.user_id = u.id
    LEFT JOIN personas p ON a.persona_id = p.id
    WHERE a.status IN ('new', 'viewed')
      AND a.severity IN ('critical', 'high')
      AND (a.expires_at IS NULL OR a.expires_at > NOW())
    ORDER BY
      CASE a.severity WHEN 'critical' THEN 1 ELSE 2 END,
      a.created_at ASC
  `);

  return result.rows.map(rowToAdminAlert);
}

/**
 * Mark alert as viewed
 */
async function markViewed(alertId, viewedBy) {
  const result = await database.query(`
    UPDATE admin_alerts
    SET status = CASE WHEN status = 'new' THEN 'viewed' ELSE status END,
        viewed_at = COALESCE(viewed_at, NOW()),
        viewed_by = COALESCE(viewed_by, $2),
        updated_at = NOW()
    WHERE id = $1
    RETURNING *
  `, [alertId, viewedBy]);

  return rowToAdminAlert(result.rows[0]);
}

/**
 * Acknowledge alert
 */
async function acknowledge(alertId, acknowledgedBy) {
  const result = await database.query(`
    UPDATE admin_alerts
    SET status = 'acknowledged',
        acknowledged_at = NOW(),
        acknowledged_by = $2,
        updated_at = NOW()
    WHERE id = $1
    RETURNING *
  `, [alertId, acknowledgedBy]);

  return rowToAdminAlert(result.rows[0]);
}

/**
 * Put alert under review
 */
async function startReview(alertId, reviewedBy) {
  const result = await database.query(`
    UPDATE admin_alerts
    SET status = 'under_review',
        updated_at = NOW()
    WHERE id = $1
    RETURNING *
  `, [alertId]);

  return rowToAdminAlert(result.rows[0]);
}

/**
 * Resolve alert
 */
async function resolve(alertId, resolvedBy, resolutionNotes = null) {
  const result = await database.query(`
    UPDATE admin_alerts
    SET status = 'resolved',
        resolved_at = NOW(),
        resolved_by = $2,
        resolution_notes = $3,
        updated_at = NOW()
    WHERE id = $1
    RETURNING *
  `, [alertId, resolvedBy, resolutionNotes]);

  return rowToAdminAlert(result.rows[0]);
}

/**
 * Escalate alert
 */
async function escalate(alertId, escalatedBy, newAuthorizationLevel = 'superadmin') {
  const result = await database.query(`
    UPDATE admin_alerts
    SET status = 'escalated',
        authorization_level = $3,
        severity = CASE
          WHEN severity IN ('low', 'moderate') THEN 'elevated'
          WHEN severity = 'elevated' THEN 'high'
          WHEN severity = 'high' THEN 'critical'
          ELSE severity
        END,
        updated_at = NOW()
    WHERE id = $1
    RETURNING *
  `, [alertId, escalatedBy, newAuthorizationLevel]);

  return rowToAdminAlert(result.rows[0]);
}

/**
 * Dismiss alert
 */
async function dismiss(alertId, dismissedBy, reason = null) {
  const result = await database.query(`
    UPDATE admin_alerts
    SET status = 'dismissed',
        resolved_at = NOW(),
        resolved_by = $2,
        resolution_notes = $3,
        updated_at = NOW()
    WHERE id = $1
    RETURNING *
  `, [alertId, dismissedBy, reason]);

  return rowToAdminAlert(result.rows[0]);
}

/**
 * Log detail access (for audit)
 */
async function logDetailAccess(alertId, accessedBy, accessType, accessGranted, denialReason = null, ipAddress = null, userAgent = null) {
  await database.query(`
    INSERT INTO admin_alert_access_log (
      alert_id, accessed_by, access_type, access_granted, denial_reason, ip_address, user_agent
    ) VALUES ($1, $2, $3, $4, $5, $6, $7)
  `, [alertId, accessedBy, accessType, accessGranted, denialReason, ipAddress, userAgent]);

  // Update alert if detail was accessed
  if (accessType === 'view_detail' && accessGranted) {
    await database.query(`
      UPDATE admin_alerts
      SET detail_accessed_at = NOW(), detail_accessed_by = $2
      WHERE id = $1 AND detail_accessed_at IS NULL
    `, [alertId, accessedBy]);
  }
}

/**
 * Get access log for an alert
 */
async function getAccessLog(alertId) {
  const result = await database.query(`
    SELECT aal.*, u.display_name as accessor_name
    FROM admin_alert_access_log aal
    LEFT JOIN users u ON aal.accessed_by = u.id
    WHERE aal.alert_id = $1
    ORDER BY aal.created_at DESC
  `, [alertId]);

  return result.rows;
}

/**
 * Check if user has authorization to view alert details
 */
async function checkAuthorization(alertId, userId) {
  const alert = await findById(alertId);
  if (!alert) return { authorized: false, reason: 'alert_not_found' };

  if (!alert.requiresAuthorization) {
    return { authorized: true };
  }

  // Get user's role
  const userResult = await database.query(
    'SELECT role FROM users WHERE id = $1',
    [userId]
  );

  if (userResult.rows.length === 0) {
    return { authorized: false, reason: 'user_not_found' };
  }

  const userRole = userResult.rows[0].role;

  // Role hierarchy for authorization
  const roleHierarchy = {
    superadmin: 100,
    admin: 80,
    counselor: 60,
    safety_reviewer: 50,
    moderator: 40,
    user: 10
  };

  const requiredLevel = roleHierarchy[alert.authorizationLevel] || 50;
  const userLevel = roleHierarchy[userRole] || 10;

  if (userLevel >= requiredLevel) {
    return { authorized: true };
  }

  return {
    authorized: false,
    reason: 'insufficient_authorization',
    required: alert.authorizationLevel,
    current: userRole
  };
}

/**
 * Find alerts by user ID (the user who triggered the alert)
 */
async function findBySubjectUserId(userId, options = {}) {
  const { limit = 50, offset = 0 } = options;

  const result = await database.query(`
    SELECT a.*, p.name as persona_name
    FROM admin_alerts a
    LEFT JOIN personas p ON a.persona_id = p.id
    WHERE a.user_id = $1
    ORDER BY a.created_at DESC
    LIMIT $2 OFFSET $3
  `, [userId, limit, offset]);

  return result.rows.map(rowToAdminAlert);
}

/**
 * Find alerts by persona ID
 */
async function findByPersonaId(personaId, options = {}) {
  const { limit = 50, offset = 0 } = options;

  const result = await database.query(`
    SELECT a.*, u.display_name as user_display_name
    FROM admin_alerts a
    LEFT JOIN users u ON a.user_id = u.id
    WHERE a.persona_id = $1
    ORDER BY a.created_at DESC
    LIMIT $2 OFFSET $3
  `, [personaId, limit, offset]);

  return result.rows.map(rowToAdminAlert);
}

/**
 * Get alert statistics
 */
async function getStatistics(options = {}) {
  const { startDate = null, endDate = null } = options;

  let dateFilter = '';
  const params = [];
  let paramIndex = 1;

  if (startDate) {
    dateFilter += ` AND a.created_at >= $${paramIndex++}`;
    params.push(startDate);
  }

  if (endDate) {
    dateFilter += ` AND a.created_at <= $${paramIndex++}`;
    params.push(endDate);
  }

  const result = await database.query(`
    SELECT
      COUNT(*) as total_alerts,
      COUNT(*) FILTER (WHERE status = 'resolved') as resolved_count,
      COUNT(*) FILTER (WHERE status = 'dismissed') as dismissed_count,
      COUNT(*) FILTER (WHERE status IN ('new', 'viewed')) as pending_count,
      COUNT(*) FILTER (WHERE severity = 'critical') as critical_count,
      COUNT(*) FILTER (WHERE severity = 'high') as high_count,
      AVG(EXTRACT(EPOCH FROM (resolved_at - created_at))) FILTER (WHERE resolved_at IS NOT NULL) as avg_resolution_seconds,
      COUNT(DISTINCT user_id) as unique_users,
      COUNT(DISTINCT persona_id) as unique_personas
    FROM admin_alerts a
    WHERE 1=1 ${dateFilter}
  `, params);

  return result.rows[0];
}

module.exports = {
  create,
  findById,
  findActive,
  countActive,
  getUrgent,
  markViewed,
  acknowledge,
  startReview,
  resolve,
  escalate,
  dismiss,
  logDetailAccess,
  getAccessLog,
  checkAuthorization,
  findBySubjectUserId,
  findByPersonaId,
  getStatistics
};
